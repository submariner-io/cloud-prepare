/*
SPDX-License-Identifier: Apache-2.0

Copyright Contributors to the Submariner project.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by mockery v2.43.2. DO NOT EDIT.

package fake

import (
	mock "github.com/stretchr/testify/mock"
	compute "google.golang.org/api/compute/v1"
)

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
	mock.Mock
}

type MockInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterface) EXPECT() *MockInterface_Expecter {
	return &MockInterface_Expecter{mock: &_m.Mock}
}

// ConfigurePublicIPOnInstance provides a mock function with given fields: instance
func (_m *MockInterface) ConfigurePublicIPOnInstance(instance *compute.Instance) error {
	ret := _m.Called(instance)

	if len(ret) == 0 {
		panic("no return value specified for ConfigurePublicIPOnInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*compute.Instance) error); ok {
		r0 = rf(instance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_ConfigurePublicIPOnInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigurePublicIPOnInstance'
type MockInterface_ConfigurePublicIPOnInstance_Call struct {
	*mock.Call
}

// ConfigurePublicIPOnInstance is a helper method to define mock.On call
//   - instance *compute.Instance
func (_e *MockInterface_Expecter) ConfigurePublicIPOnInstance(instance interface{}) *MockInterface_ConfigurePublicIPOnInstance_Call {
	return &MockInterface_ConfigurePublicIPOnInstance_Call{Call: _e.mock.On("ConfigurePublicIPOnInstance", instance)}
}

func (_c *MockInterface_ConfigurePublicIPOnInstance_Call) Run(run func(instance *compute.Instance)) *MockInterface_ConfigurePublicIPOnInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*compute.Instance))
	})
	return _c
}

func (_c *MockInterface_ConfigurePublicIPOnInstance_Call) Return(_a0 error) *MockInterface_ConfigurePublicIPOnInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_ConfigurePublicIPOnInstance_Call) RunAndReturn(run func(*compute.Instance) error) *MockInterface_ConfigurePublicIPOnInstance_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFirewallRule provides a mock function with given fields: projectID, name
func (_m *MockInterface) DeleteFirewallRule(projectID string, name string) error {
	ret := _m.Called(projectID, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFirewallRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(projectID, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_DeleteFirewallRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFirewallRule'
type MockInterface_DeleteFirewallRule_Call struct {
	*mock.Call
}

// DeleteFirewallRule is a helper method to define mock.On call
//   - projectID string
//   - name string
func (_e *MockInterface_Expecter) DeleteFirewallRule(projectID interface{}, name interface{}) *MockInterface_DeleteFirewallRule_Call {
	return &MockInterface_DeleteFirewallRule_Call{Call: _e.mock.On("DeleteFirewallRule", projectID, name)}
}

func (_c *MockInterface_DeleteFirewallRule_Call) Run(run func(projectID string, name string)) *MockInterface_DeleteFirewallRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockInterface_DeleteFirewallRule_Call) Return(_a0 error) *MockInterface_DeleteFirewallRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_DeleteFirewallRule_Call) RunAndReturn(run func(string, string) error) *MockInterface_DeleteFirewallRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePublicIPOnInstance provides a mock function with given fields: instance
func (_m *MockInterface) DeletePublicIPOnInstance(instance *compute.Instance) error {
	ret := _m.Called(instance)

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicIPOnInstance")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*compute.Instance) error); ok {
		r0 = rf(instance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_DeletePublicIPOnInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePublicIPOnInstance'
type MockInterface_DeletePublicIPOnInstance_Call struct {
	*mock.Call
}

// DeletePublicIPOnInstance is a helper method to define mock.On call
//   - instance *compute.Instance
func (_e *MockInterface_Expecter) DeletePublicIPOnInstance(instance interface{}) *MockInterface_DeletePublicIPOnInstance_Call {
	return &MockInterface_DeletePublicIPOnInstance_Call{Call: _e.mock.On("DeletePublicIPOnInstance", instance)}
}

func (_c *MockInterface_DeletePublicIPOnInstance_Call) Run(run func(instance *compute.Instance)) *MockInterface_DeletePublicIPOnInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*compute.Instance))
	})
	return _c
}

func (_c *MockInterface_DeletePublicIPOnInstance_Call) Return(_a0 error) *MockInterface_DeletePublicIPOnInstance_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_DeletePublicIPOnInstance_Call) RunAndReturn(run func(*compute.Instance) error) *MockInterface_DeletePublicIPOnInstance_Call {
	_c.Call.Return(run)
	return _c
}

// GetFirewallRule provides a mock function with given fields: projectID, name
func (_m *MockInterface) GetFirewallRule(projectID string, name string) (*compute.Firewall, error) {
	ret := _m.Called(projectID, name)

	if len(ret) == 0 {
		panic("no return value specified for GetFirewallRule")
	}

	var r0 *compute.Firewall
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*compute.Firewall, error)); ok {
		return rf(projectID, name)
	}
	if rf, ok := ret.Get(0).(func(string, string) *compute.Firewall); ok {
		r0 = rf(projectID, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*compute.Firewall)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectID, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetFirewallRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFirewallRule'
type MockInterface_GetFirewallRule_Call struct {
	*mock.Call
}

// GetFirewallRule is a helper method to define mock.On call
//   - projectID string
//   - name string
func (_e *MockInterface_Expecter) GetFirewallRule(projectID interface{}, name interface{}) *MockInterface_GetFirewallRule_Call {
	return &MockInterface_GetFirewallRule_Call{Call: _e.mock.On("GetFirewallRule", projectID, name)}
}

func (_c *MockInterface_GetFirewallRule_Call) Run(run func(projectID string, name string)) *MockInterface_GetFirewallRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockInterface_GetFirewallRule_Call) Return(_a0 *compute.Firewall, _a1 error) *MockInterface_GetFirewallRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetFirewallRule_Call) RunAndReturn(run func(string, string) (*compute.Firewall, error)) *MockInterface_GetFirewallRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstance provides a mock function with given fields: zone, instance
func (_m *MockInterface) GetInstance(zone string, instance string) (*compute.Instance, error) {
	ret := _m.Called(zone, instance)

	if len(ret) == 0 {
		panic("no return value specified for GetInstance")
	}

	var r0 *compute.Instance
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*compute.Instance, error)); ok {
		return rf(zone, instance)
	}
	if rf, ok := ret.Get(0).(func(string, string) *compute.Instance); ok {
		r0 = rf(zone, instance)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*compute.Instance)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(zone, instance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetInstance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstance'
type MockInterface_GetInstance_Call struct {
	*mock.Call
}

// GetInstance is a helper method to define mock.On call
//   - zone string
//   - instance string
func (_e *MockInterface_Expecter) GetInstance(zone interface{}, instance interface{}) *MockInterface_GetInstance_Call {
	return &MockInterface_GetInstance_Call{Call: _e.mock.On("GetInstance", zone, instance)}
}

func (_c *MockInterface_GetInstance_Call) Run(run func(zone string, instance string)) *MockInterface_GetInstance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockInterface_GetInstance_Call) Return(_a0 *compute.Instance, _a1 error) *MockInterface_GetInstance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetInstance_Call) RunAndReturn(run func(string, string) (*compute.Instance, error)) *MockInterface_GetInstance_Call {
	_c.Call.Return(run)
	return _c
}

// InsertFirewallRule provides a mock function with given fields: projectID, rule
func (_m *MockInterface) InsertFirewallRule(projectID string, rule *compute.Firewall) error {
	ret := _m.Called(projectID, rule)

	if len(ret) == 0 {
		panic("no return value specified for InsertFirewallRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *compute.Firewall) error); ok {
		r0 = rf(projectID, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_InsertFirewallRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertFirewallRule'
type MockInterface_InsertFirewallRule_Call struct {
	*mock.Call
}

// InsertFirewallRule is a helper method to define mock.On call
//   - projectID string
//   - rule *compute.Firewall
func (_e *MockInterface_Expecter) InsertFirewallRule(projectID interface{}, rule interface{}) *MockInterface_InsertFirewallRule_Call {
	return &MockInterface_InsertFirewallRule_Call{Call: _e.mock.On("InsertFirewallRule", projectID, rule)}
}

func (_c *MockInterface_InsertFirewallRule_Call) Run(run func(projectID string, rule *compute.Firewall)) *MockInterface_InsertFirewallRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*compute.Firewall))
	})
	return _c
}

func (_c *MockInterface_InsertFirewallRule_Call) Return(_a0 error) *MockInterface_InsertFirewallRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_InsertFirewallRule_Call) RunAndReturn(run func(string, *compute.Firewall) error) *MockInterface_InsertFirewallRule_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceHasPublicIP provides a mock function with given fields: instance
func (_m *MockInterface) InstanceHasPublicIP(instance *compute.Instance) (bool, error) {
	ret := _m.Called(instance)

	if len(ret) == 0 {
		panic("no return value specified for InstanceHasPublicIP")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*compute.Instance) (bool, error)); ok {
		return rf(instance)
	}
	if rf, ok := ret.Get(0).(func(*compute.Instance) bool); ok {
		r0 = rf(instance)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*compute.Instance) error); ok {
		r1 = rf(instance)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_InstanceHasPublicIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceHasPublicIP'
type MockInterface_InstanceHasPublicIP_Call struct {
	*mock.Call
}

// InstanceHasPublicIP is a helper method to define mock.On call
//   - instance *compute.Instance
func (_e *MockInterface_Expecter) InstanceHasPublicIP(instance interface{}) *MockInterface_InstanceHasPublicIP_Call {
	return &MockInterface_InstanceHasPublicIP_Call{Call: _e.mock.On("InstanceHasPublicIP", instance)}
}

func (_c *MockInterface_InstanceHasPublicIP_Call) Run(run func(instance *compute.Instance)) *MockInterface_InstanceHasPublicIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*compute.Instance))
	})
	return _c
}

func (_c *MockInterface_InstanceHasPublicIP_Call) Return(_a0 bool, _a1 error) *MockInterface_InstanceHasPublicIP_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_InstanceHasPublicIP_Call) RunAndReturn(run func(*compute.Instance) (bool, error)) *MockInterface_InstanceHasPublicIP_Call {
	_c.Call.Return(run)
	return _c
}

// ListInstances provides a mock function with given fields: zone
func (_m *MockInterface) ListInstances(zone string) (*compute.InstanceList, error) {
	ret := _m.Called(zone)

	if len(ret) == 0 {
		panic("no return value specified for ListInstances")
	}

	var r0 *compute.InstanceList
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*compute.InstanceList, error)); ok {
		return rf(zone)
	}
	if rf, ok := ret.Get(0).(func(string) *compute.InstanceList); ok {
		r0 = rf(zone)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*compute.InstanceList)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(zone)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_ListInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInstances'
type MockInterface_ListInstances_Call struct {
	*mock.Call
}

// ListInstances is a helper method to define mock.On call
//   - zone string
func (_e *MockInterface_Expecter) ListInstances(zone interface{}) *MockInterface_ListInstances_Call {
	return &MockInterface_ListInstances_Call{Call: _e.mock.On("ListInstances", zone)}
}

func (_c *MockInterface_ListInstances_Call) Run(run func(zone string)) *MockInterface_ListInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockInterface_ListInstances_Call) Return(_a0 *compute.InstanceList, _a1 error) *MockInterface_ListInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_ListInstances_Call) RunAndReturn(run func(string) (*compute.InstanceList, error)) *MockInterface_ListInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListZones provides a mock function with given fields:
func (_m *MockInterface) ListZones() (*compute.ZoneList, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ListZones")
	}

	var r0 *compute.ZoneList
	var r1 error
	if rf, ok := ret.Get(0).(func() (*compute.ZoneList, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *compute.ZoneList); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*compute.ZoneList)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_ListZones_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListZones'
type MockInterface_ListZones_Call struct {
	*mock.Call
}

// ListZones is a helper method to define mock.On call
func (_e *MockInterface_Expecter) ListZones() *MockInterface_ListZones_Call {
	return &MockInterface_ListZones_Call{Call: _e.mock.On("ListZones")}
}

func (_c *MockInterface_ListZones_Call) Run(run func()) *MockInterface_ListZones_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockInterface_ListZones_Call) Return(_a0 *compute.ZoneList, _a1 error) *MockInterface_ListZones_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_ListZones_Call) RunAndReturn(run func() (*compute.ZoneList, error)) *MockInterface_ListZones_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateFirewallRule provides a mock function with given fields: projectID, name, rule
func (_m *MockInterface) UpdateFirewallRule(projectID string, name string, rule *compute.Firewall) error {
	ret := _m.Called(projectID, name, rule)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFirewallRule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, *compute.Firewall) error); ok {
		r0 = rf(projectID, name, rule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_UpdateFirewallRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateFirewallRule'
type MockInterface_UpdateFirewallRule_Call struct {
	*mock.Call
}

// UpdateFirewallRule is a helper method to define mock.On call
//   - projectID string
//   - name string
//   - rule *compute.Firewall
func (_e *MockInterface_Expecter) UpdateFirewallRule(projectID interface{}, name interface{}, rule interface{}) *MockInterface_UpdateFirewallRule_Call {
	return &MockInterface_UpdateFirewallRule_Call{Call: _e.mock.On("UpdateFirewallRule", projectID, name, rule)}
}

func (_c *MockInterface_UpdateFirewallRule_Call) Run(run func(projectID string, name string, rule *compute.Firewall)) *MockInterface_UpdateFirewallRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(*compute.Firewall))
	})
	return _c
}

func (_c *MockInterface_UpdateFirewallRule_Call) Return(_a0 error) *MockInterface_UpdateFirewallRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_UpdateFirewallRule_Call) RunAndReturn(run func(string, string, *compute.Firewall) error) *MockInterface_UpdateFirewallRule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateInstanceNetworkTags provides a mock function with given fields: project, zone, instance, tags
func (_m *MockInterface) UpdateInstanceNetworkTags(project string, zone string, instance string, tags *compute.Tags) error {
	ret := _m.Called(project, zone, instance, tags)

	if len(ret) == 0 {
		panic("no return value specified for UpdateInstanceNetworkTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *compute.Tags) error); ok {
		r0 = rf(project, zone, instance, tags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_UpdateInstanceNetworkTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateInstanceNetworkTags'
type MockInterface_UpdateInstanceNetworkTags_Call struct {
	*mock.Call
}

// UpdateInstanceNetworkTags is a helper method to define mock.On call
//   - project string
//   - zone string
//   - instance string
//   - tags *compute.Tags
func (_e *MockInterface_Expecter) UpdateInstanceNetworkTags(project interface{}, zone interface{}, instance interface{}, tags interface{}) *MockInterface_UpdateInstanceNetworkTags_Call {
	return &MockInterface_UpdateInstanceNetworkTags_Call{Call: _e.mock.On("UpdateInstanceNetworkTags", project, zone, instance, tags)}
}

func (_c *MockInterface_UpdateInstanceNetworkTags_Call) Run(run func(project string, zone string, instance string, tags *compute.Tags)) *MockInterface_UpdateInstanceNetworkTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string), args[3].(*compute.Tags))
	})
	return _c
}

func (_c *MockInterface_UpdateInstanceNetworkTags_Call) Return(_a0 error) *MockInterface_UpdateInstanceNetworkTags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_UpdateInstanceNetworkTags_Call) RunAndReturn(run func(string, string, string, *compute.Tags) error) *MockInterface_UpdateInstanceNetworkTags_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterface creates a new instance of MockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterface {
	mock := &MockInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
