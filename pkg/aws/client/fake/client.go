/*
SPDX-License-Identifier: Apache-2.0

Copyright Contributors to the Submariner project.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by mockery v2.43.2. DO NOT EDIT.

package fake

import (
	context "context"

	ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
	mock "github.com/stretchr/testify/mock"
)

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
	mock.Mock
}

type MockInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterface) EXPECT() *MockInterface_Expecter {
	return &MockInterface_Expecter{mock: &_m.Mock}
}

// AuthorizeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) AuthorizeSecurityGroupIngress(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AuthorizeSecurityGroupIngress")
	}

	var r0 *ec2.AuthorizeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.AuthorizeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.AuthorizeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_AuthorizeSecurityGroupIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthorizeSecurityGroupIngress'
type MockInterface_AuthorizeSecurityGroupIngress_Call struct {
	*mock.Call
}

// AuthorizeSecurityGroupIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.AuthorizeSecurityGroupIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) AuthorizeSecurityGroupIngress(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_AuthorizeSecurityGroupIngress_Call {
	return &MockInterface_AuthorizeSecurityGroupIngress_Call{Call: _e.mock.On("AuthorizeSecurityGroupIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_AuthorizeSecurityGroupIngress_Call) Run(run func(ctx context.Context, params *ec2.AuthorizeSecurityGroupIngressInput, optFns ...func(*ec2.Options))) *MockInterface_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.AuthorizeSecurityGroupIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_AuthorizeSecurityGroupIngress_Call) Return(_a0 *ec2.AuthorizeSecurityGroupIngressOutput, _a1 error) *MockInterface_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_AuthorizeSecurityGroupIngress_Call) RunAndReturn(run func(context.Context, *ec2.AuthorizeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.AuthorizeSecurityGroupIngressOutput, error)) *MockInterface_AuthorizeSecurityGroupIngress_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) CreateSecurityGroup(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSecurityGroup")
	}

	var r0 *ec2.CreateSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) *ec2.CreateSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_CreateSecurityGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSecurityGroup'
type MockInterface_CreateSecurityGroup_Call struct {
	*mock.Call
}

// CreateSecurityGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateSecurityGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) CreateSecurityGroup(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_CreateSecurityGroup_Call {
	return &MockInterface_CreateSecurityGroup_Call{Call: _e.mock.On("CreateSecurityGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_CreateSecurityGroup_Call) Run(run func(ctx context.Context, params *ec2.CreateSecurityGroupInput, optFns ...func(*ec2.Options))) *MockInterface_CreateSecurityGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateSecurityGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_CreateSecurityGroup_Call) Return(_a0 *ec2.CreateSecurityGroupOutput, _a1 error) *MockInterface_CreateSecurityGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_CreateSecurityGroup_Call) RunAndReturn(run func(context.Context, *ec2.CreateSecurityGroupInput, ...func(*ec2.Options)) (*ec2.CreateSecurityGroupOutput, error)) *MockInterface_CreateSecurityGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTags provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTags")
	}

	var r0 *ec2.CreateTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) *ec2.CreateTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.CreateTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_CreateTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTags'
type MockInterface_CreateTags_Call struct {
	*mock.Call
}

// CreateTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.CreateTagsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) CreateTags(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_CreateTags_Call {
	return &MockInterface_CreateTags_Call{Call: _e.mock.On("CreateTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_CreateTags_Call) Run(run func(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options))) *MockInterface_CreateTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.CreateTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_CreateTags_Call) Return(_a0 *ec2.CreateTagsOutput, _a1 error) *MockInterface_CreateTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_CreateTags_Call) RunAndReturn(run func(context.Context, *ec2.CreateTagsInput, ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error)) *MockInterface_CreateTags_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSecurityGroup provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DeleteSecurityGroup(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecurityGroup")
	}

	var r0 *ec2.DeleteSecurityGroupOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) *ec2.DeleteSecurityGroupOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteSecurityGroupOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DeleteSecurityGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSecurityGroup'
type MockInterface_DeleteSecurityGroup_Call struct {
	*mock.Call
}

// DeleteSecurityGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteSecurityGroupInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DeleteSecurityGroup(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DeleteSecurityGroup_Call {
	return &MockInterface_DeleteSecurityGroup_Call{Call: _e.mock.On("DeleteSecurityGroup",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DeleteSecurityGroup_Call) Run(run func(ctx context.Context, params *ec2.DeleteSecurityGroupInput, optFns ...func(*ec2.Options))) *MockInterface_DeleteSecurityGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteSecurityGroupInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DeleteSecurityGroup_Call) Return(_a0 *ec2.DeleteSecurityGroupOutput, _a1 error) *MockInterface_DeleteSecurityGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DeleteSecurityGroup_Call) RunAndReturn(run func(context.Context, *ec2.DeleteSecurityGroupInput, ...func(*ec2.Options)) (*ec2.DeleteSecurityGroupOutput, error)) *MockInterface_DeleteSecurityGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTags provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DeleteTags(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTags")
	}

	var r0 *ec2.DeleteTagsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) *ec2.DeleteTagsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DeleteTagsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DeleteTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTags'
type MockInterface_DeleteTags_Call struct {
	*mock.Call
}

// DeleteTags is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DeleteTagsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DeleteTags(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DeleteTags_Call {
	return &MockInterface_DeleteTags_Call{Call: _e.mock.On("DeleteTags",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DeleteTags_Call) Run(run func(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options))) *MockInterface_DeleteTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DeleteTagsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DeleteTags_Call) Return(_a0 *ec2.DeleteTagsOutput, _a1 error) *MockInterface_DeleteTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DeleteTags_Call) RunAndReturn(run func(context.Context, *ec2.DeleteTagsInput, ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error)) *MockInterface_DeleteTags_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstanceTypeOfferings provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DescribeInstanceTypeOfferings(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstanceTypeOfferings")
	}

	var r0 *ec2.DescribeInstanceTypeOfferingsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) *ec2.DescribeInstanceTypeOfferingsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstanceTypeOfferingsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeInstanceTypeOfferings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstanceTypeOfferings'
type MockInterface_DescribeInstanceTypeOfferings_Call struct {
	*mock.Call
}

// DescribeInstanceTypeOfferings is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstanceTypeOfferingsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DescribeInstanceTypeOfferings(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DescribeInstanceTypeOfferings_Call {
	return &MockInterface_DescribeInstanceTypeOfferings_Call{Call: _e.mock.On("DescribeInstanceTypeOfferings",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DescribeInstanceTypeOfferings_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstanceTypeOfferingsInput, optFns ...func(*ec2.Options))) *MockInterface_DescribeInstanceTypeOfferings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstanceTypeOfferingsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DescribeInstanceTypeOfferings_Call) Return(_a0 *ec2.DescribeInstanceTypeOfferingsOutput, _a1 error) *MockInterface_DescribeInstanceTypeOfferings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeInstanceTypeOfferings_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstanceTypeOfferingsInput, ...func(*ec2.Options)) (*ec2.DescribeInstanceTypeOfferingsOutput, error)) *MockInterface_DescribeInstanceTypeOfferings_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeInstances provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeInstances")
	}

	var r0 *ec2.DescribeInstancesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) *ec2.DescribeInstancesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeInstancesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeInstances'
type MockInterface_DescribeInstances_Call struct {
	*mock.Call
}

// DescribeInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeInstancesInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DescribeInstances(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DescribeInstances_Call {
	return &MockInterface_DescribeInstances_Call{Call: _e.mock.On("DescribeInstances",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DescribeInstances_Call) Run(run func(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options))) *MockInterface_DescribeInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeInstancesInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DescribeInstances_Call) Return(_a0 *ec2.DescribeInstancesOutput, _a1 error) *MockInterface_DescribeInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeInstances_Call) RunAndReturn(run func(context.Context, *ec2.DescribeInstancesInput, ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error)) *MockInterface_DescribeInstances_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSecurityGroups provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DescribeSecurityGroups(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSecurityGroups")
	}

	var r0 *ec2.DescribeSecurityGroupsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) *ec2.DescribeSecurityGroupsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSecurityGroupsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeSecurityGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSecurityGroups'
type MockInterface_DescribeSecurityGroups_Call struct {
	*mock.Call
}

// DescribeSecurityGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSecurityGroupsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DescribeSecurityGroups(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DescribeSecurityGroups_Call {
	return &MockInterface_DescribeSecurityGroups_Call{Call: _e.mock.On("DescribeSecurityGroups",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DescribeSecurityGroups_Call) Run(run func(ctx context.Context, params *ec2.DescribeSecurityGroupsInput, optFns ...func(*ec2.Options))) *MockInterface_DescribeSecurityGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSecurityGroupsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DescribeSecurityGroups_Call) Return(_a0 *ec2.DescribeSecurityGroupsOutput, _a1 error) *MockInterface_DescribeSecurityGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeSecurityGroups_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSecurityGroupsInput, ...func(*ec2.Options)) (*ec2.DescribeSecurityGroupsOutput, error)) *MockInterface_DescribeSecurityGroups_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSubnets provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSubnets")
	}

	var r0 *ec2.DescribeSubnetsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) *ec2.DescribeSubnetsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeSubnetsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeSubnets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSubnets'
type MockInterface_DescribeSubnets_Call struct {
	*mock.Call
}

// DescribeSubnets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeSubnetsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DescribeSubnets(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DescribeSubnets_Call {
	return &MockInterface_DescribeSubnets_Call{Call: _e.mock.On("DescribeSubnets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DescribeSubnets_Call) Run(run func(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options))) *MockInterface_DescribeSubnets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeSubnetsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DescribeSubnets_Call) Return(_a0 *ec2.DescribeSubnetsOutput, _a1 error) *MockInterface_DescribeSubnets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeSubnets_Call) RunAndReturn(run func(context.Context, *ec2.DescribeSubnetsInput, ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error)) *MockInterface_DescribeSubnets_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeVpcs provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) DescribeVpcs(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeVpcs")
	}

	var r0 *ec2.DescribeVpcsOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) *ec2.DescribeVpcsOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.DescribeVpcsOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeVpcs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeVpcs'
type MockInterface_DescribeVpcs_Call struct {
	*mock.Call
}

// DescribeVpcs is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.DescribeVpcsInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) DescribeVpcs(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_DescribeVpcs_Call {
	return &MockInterface_DescribeVpcs_Call{Call: _e.mock.On("DescribeVpcs",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_DescribeVpcs_Call) Run(run func(ctx context.Context, params *ec2.DescribeVpcsInput, optFns ...func(*ec2.Options))) *MockInterface_DescribeVpcs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.DescribeVpcsInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_DescribeVpcs_Call) Return(_a0 *ec2.DescribeVpcsOutput, _a1 error) *MockInterface_DescribeVpcs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeVpcs_Call) RunAndReturn(run func(context.Context, *ec2.DescribeVpcsInput, ...func(*ec2.Options)) (*ec2.DescribeVpcsOutput, error)) *MockInterface_DescribeVpcs_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeSecurityGroupIngress provides a mock function with given fields: ctx, params, optFns
func (_m *MockInterface) RevokeSecurityGroupIngress(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeSecurityGroupIngress")
	}

	var r0 *ec2.RevokeSecurityGroupIngressOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) *ec2.RevokeSecurityGroupIngressOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ec2.RevokeSecurityGroupIngressOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_RevokeSecurityGroupIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeSecurityGroupIngress'
type MockInterface_RevokeSecurityGroupIngress_Call struct {
	*mock.Call
}

// RevokeSecurityGroupIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - params *ec2.RevokeSecurityGroupIngressInput
//   - optFns ...func(*ec2.Options)
func (_e *MockInterface_Expecter) RevokeSecurityGroupIngress(ctx interface{}, params interface{}, optFns ...interface{}) *MockInterface_RevokeSecurityGroupIngress_Call {
	return &MockInterface_RevokeSecurityGroupIngress_Call{Call: _e.mock.On("RevokeSecurityGroupIngress",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInterface_RevokeSecurityGroupIngress_Call) Run(run func(ctx context.Context, params *ec2.RevokeSecurityGroupIngressInput, optFns ...func(*ec2.Options))) *MockInterface_RevokeSecurityGroupIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*ec2.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*ec2.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*ec2.RevokeSecurityGroupIngressInput), variadicArgs...)
	})
	return _c
}

func (_c *MockInterface_RevokeSecurityGroupIngress_Call) Return(_a0 *ec2.RevokeSecurityGroupIngressOutput, _a1 error) *MockInterface_RevokeSecurityGroupIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_RevokeSecurityGroupIngress_Call) RunAndReturn(run func(context.Context, *ec2.RevokeSecurityGroupIngressInput, ...func(*ec2.Options)) (*ec2.RevokeSecurityGroupIngressOutput, error)) *MockInterface_RevokeSecurityGroupIngress_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterface creates a new instance of MockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterface {
	mock := &MockInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
